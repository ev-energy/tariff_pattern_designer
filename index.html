<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schema Designer (React)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        // Import the date-holidays library using its ESM endpoint
        // and assign the default export (the Holidays class) to the global window object.
        import HolidaysESM from 'https://cdn.jsdelivr.net/npm/date-holidays@3.24.3/+esm';
        window.Holidays = HolidaysESM;
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar styling */
        #jsonOutputReact::-webkit-scrollbar,
        .tariff-rules-container::-webkit-scrollbar,
        .weekday-groups-container::-webkit-scrollbar,
        .holiday-month-rules-container::-webkit-scrollbar,
        .override-rules-container::-webkit-scrollbar,
        #fetchedHolidaysList::-webkit-scrollbar {
            width: 8px; height: 8px;
        }
        #jsonOutputReact::-webkit-scrollbar-track,
        .tariff-rules-container::-webkit-scrollbar-track,
        .weekday-groups-container::-webkit-scrollbar-track,
        .holiday-month-rules-container::-webkit-scrollbar-track,
        .override-rules-container::-webkit-scrollbar-track,
        #fetchedHolidaysList::-webkit-scrollbar-track {
            background: #f1f1f1; border-radius: 10px;
        }
        #jsonOutputReact::-webkit-scrollbar-thumb,
        .tariff-rules-container::-webkit-scrollbar-thumb,
        .weekday-groups-container::-webkit-scrollbar-thumb,
        .holiday-month-rules-container::-webkit-scrollbar-thumb,
        .override-rules-container::-webkit-scrollbar-thumb,
        #fetchedHolidaysList::-webkit-scrollbar-thumb {
            background: #888; border-radius: 10px;
        }
        #jsonOutputReact::-webkit-scrollbar-thumb:hover,
        .tariff-rules-container::-webkit-scrollbar-thumb:hover,
        .weekday-groups-container::-webkit-scrollbar-thumb:hover,
        .holiday-month-rules-container::-webkit-scrollbar-thumb:hover,
        .override-rules-container::-webkit-scrollbar-thumb:hover,
        #fetchedHolidaysList::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .label-cb { display: flex; align-items: center; cursor: pointer; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .section-container {
            border: 1px solid #d1d5db; border-radius: 0.75rem; padding: 1.5rem;
            margin-bottom: 2rem; background-color: #ffffff;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
        }
        .section-header {
            font-size: 1.5rem; font-weight: 700; color: #1d4ed8;
            margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid #93c5fd;
        }

        .tariff-rule, .weekday-group, .holiday-month-rule, .override-rule {
            border: 1px solid #e5e7eb; border-radius: 0.75rem; padding: 1.5rem;
            margin-bottom: 1.5rem; background-color: #f9fafb;
        }
        .subsection-title {
            font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem;
            color: #374151; border-bottom: 1px solid #d1d5db; padding-bottom: 0.5rem;
        }
        .remove-btn {
             background-color: #ef4444; color: white; font-weight: 600;
             padding: 0.5rem 0.75rem; border-radius: 0.375rem; font-size: 0.875rem;
        }
        .remove-btn:hover { background-color: #dc2626; }
        .add-btn {
            background-color: #22c55e; color: white; font-weight: 600;
            padding: 0.5rem 1rem; border-radius: 0.5rem;
        }
        .add-btn:hover { background-color: #16a34a; }

        #statusMessageReact { min-height: 2.5rem; display: flex; align-items: center; justify-content: center; }
        .input-field {
            margin-top: 0.25rem; display: block; width: 100%; border-radius: 0.375rem;
            border-color: #d1d5db; box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05);
            padding: 0.5rem 0.75rem; font-size: 0.875rem;
        }
        .input-label { display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.25rem;}

        .quick-start-btn {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            font-weight: 500; /* medium */
            padding: 0.625rem 1.25rem; /* py-2.5 px-5 */
            border-radius: 0.5rem; /* rounded-lg */
            transition: background-color 0.15s ease-in-out;
            box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06);
        }
        .quick-start-btn:hover {
            background-color: #4338ca; /* indigo-700 */
        }
        #fetchedHolidaysList {
            max-height: 200px; /* Limit height and make scrollable */
            overflow-y: auto;
            background-color: #eef2ff; /* indigo-50 for slight contrast */
            padding: 0.75rem; /* p-3 */
            border-radius: 0.375rem; /* rounded-md */
            border: 1px solid #c7d2fe; /* indigo-200 */
        }
        /* Style for the sticky chart section */
        .sticky-chart-section {
            position: -webkit-sticky; /* Safari */
            position: sticky;
            top: 1rem; /* Adjust this value based on your header or desired offset */
            z-index: 10; /* Ensure it stays on top */
        }
        .chart-warning-icon {
            display: inline-block;
            margin-left: 0.75rem;
            color: #f59e0b; /* amber-500 */
            cursor: help;
            position: relative;
        }
        .chart-warning-icon .tooltip-text {
            visibility: hidden;
            width: 300px;
            background-color: #374151;
            color: #fff;
            text-align: left;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            position: absolute;
            z-index: 20;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem;
            line-height: 1.25;
            white-space: pre-line;
            pointer-events: none;
        }
        .chart-warning-icon:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 700;
            color: #4f46e5; /* indigo-600 */
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #818cf8; /* indigo-300 */
        }
        .collapsible-header:hover {
            color: #4338ca; /* indigo-700 */
        }
        .collapsible-arrow {
            transition: transform 0.3s ease-in-out;
        }
        .collapsible-arrow.rotated {
            transform: rotate(90deg);
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">
    <div id="root"></div>

    <script type="text/babel" data-presets="react">
        const { useState, useEffect, useCallback, useMemo, useRef } = React;

        // --- Constants ---
        const MONTHS_DATA = [
            { name: "January", value: 1 }, { name: "February", value: 2 }, { name: "March", value: 3 },
            { name: "April", value: 4 }, { name: "May", value: 5 }, { name: "June", value: 6 },
            { name: "July", value: 7 }, { name: "August", value: 8 }, { name: "September", value: 9 },
            { name: "October", value: 10 }, { name: "November", value: 11 }, { name: "December", value: 12 }
        ];
        const WEEKDAYS_DATA = [
            { name: "Monday", value: 1 }, { name: "Tuesday", value: 2 }, { name: "Wednesday", value: 3 },
            { name: "Thursday", value: 4 }, { name: "Friday", value: 5 }, { name: "Saturday", value: 6 },
            { name: "Sunday", value: 7 }
        ];
        const ALL_MONTH_NUMBERS = MONTHS_DATA.map(m => m.value);
        const ALL_WEEKDAY_NUMBERS = WEEKDAYS_DATA.map(wd => wd.value);
        const MINUTES_IN_DAY = 24 * 60;

        // --- Helper Functions ---
        const generateId = () => `id-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), delay);
            };
        };

        const timeStringToMinutes = (timeStr) => {
            if (!timeStr || typeof timeStr !== 'string') return 0;
            // Handle HH:mm:ss or HH:mm
            const parts = timeStr.split(':');
            if (parts.length < 2) return 0; // Not a valid time format

            const hours = parseInt(parts[0], 10);
            const minutes = parseInt(parts[1], 10);

            if (isNaN(hours) || isNaN(minutes)) return 0; // Invalid numbers

            return (hours * 60) + minutes;
        };

        const formatTimeForDisplay = (minutesTotal) => {
            const hours = Math.floor(minutesTotal / 60) % 24;
            const minutes = minutesTotal % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        };

        // --- Reusable UI Components ---
        const CheckboxGroup = ({ items, selectedItems, onChange, allText, groupName }) => {
            const handleSelectAll = (e) => {
                const newSelectedItems = e.target.checked ? items.map(item => item.value) : [];
                onChange(newSelectedItems);
            };

            const handleItemChange = (itemValue, checked) => {
                const newSelectedItems = checked
                    ? [...selectedItems, itemValue]
                    : selectedItems.filter(value => value !== itemValue);
                onChange(newSelectedItems);
            };

            const areAllSelected = items.length > 0 && selectedItems.length === items.length;
            const areSomeSelected = selectedItems.length > 0 && !areAllSelected;

            return (
                <div>
                    <label className="label-cb text-gray-700 font-medium mb-2 block">
                        <input
                            type="checkbox"
                            className="mr-2 h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                            checked={areAllSelected}
                            ref={el => el && (el.indeterminate = areSomeSelected)}
                            onChange={handleSelectAll}
                        />
                        {allText}
                    </label>
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
                        {items.map(item => (
                            <label key={`${groupName}-${item.value}`} className="label-cb text-sm text-gray-600 hover:text-blue-600">
                                <input
                                    type="checkbox"
                                    value={item.value}
                                    checked={selectedItems.includes(item.value)}
                                    className="mr-2 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                                    onChange={(e) => handleItemChange(item.value, e.target.checked)}
                                />
                                {item.name}
                            </label>
                        ))}
                    </div>
                </div>
            );
        };

        const RatePeriod = ({ period, onChange, onRemove }) => {
            const [displayAmount, setDisplayAmount] = useState(period.amount.toString());

            useEffect(() => {
                if (parseFloat(displayAmount) !== period.amount) {
                    setDisplayAmount(period.amount.toString());
                }
            }, [period.amount]);


            const handleTimeChange = (e, field) => {
                let value = e.target.value;
                if (value) {
                    const [hStr, mStr] = value.split(':');
                    const h = parseInt(hStr, 10);
                    let m = parseInt(mStr, 10);
                    if (!isNaN(h) && !isNaN(m)) {
                         if (m !== 0 && m !== 30) {
                            m = (m < 15 || m >= 45) ? 0 : 30;
                            value = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                        }
                    }
                }
                onChange({ ...period, [field]: value });
            };

            const handleAmountInputChange = (e) => {
                const stringValue = e.target.value;
                setDisplayAmount(stringValue); 

                if (stringValue === '') {
                    onChange({ ...period, amount: 0 });
                    return;
                }

                const parsedNum = parseFloat(stringValue);

                if (!isNaN(parsedNum)) {
                    onChange({ ...period, amount: parsedNum });
                }
            };

            return (
                <div className="p-3 border border-gray-200 rounded-md grid grid-cols-1 sm:grid-cols-8 gap-2 items-center bg-white shadow-sm text-sm">
                    <div className="sm:col-span-2 grid grid-cols-1 gap-1">
                        <label className="block text-xs font-medium text-gray-700">Start:</label>
                        <input
                            type="time"
                            value={period.start}
                            onChange={(e) => handleTimeChange(e, 'start')}
                            className="input-field text-xs rate-start-time"
                            step="1800"
                        />
                    </div>
                    <div className="sm:col-span-2 grid grid-cols-1 gap-1">
                        <label className="block text-xs font-medium text-gray-700">End:</label>
                        <input
                            type="time"
                            value={period.end}
                            onChange={(e) => handleTimeChange(e, 'end')}
                            className="input-field text-xs rate-end-time"
                            step="1800"
                        />
                    </div>
                    <div className="sm:col-span-2 grid grid-cols-1 gap-1">
                        <label className="block text-xs font-medium text-gray-700">Amount:</label>
                        <input
                            type="number"
                            step="0.0001"
                            value={displayAmount}
                            onChange={handleAmountInputChange}
                            className="input-field text-xs rate-amount"
                        />
                    </div>
                    <div className="sm:col-span-1 flex items-center justify-start sm:justify-center pt-2 sm:pt-0 group relative">
                        <input
                            type="checkbox"
                            id={`isOffpeak-${period.id}`}
                            checked={!!period.isOffpeak}
                            onChange={(e) => onChange({ ...period, isOffpeak: e.target.checked })}
                            className="mr-1.5 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 cursor-pointer"
                        />
                        <label htmlFor={`isOffpeak-${period.id}`} className="text-xs text-gray-700 cursor-pointer select-none">
                            Off-peak
                        </label>
                        <span className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 w-max max-w-xs px-2 py-1 bg-gray-700 text-white text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-normal">
                            If this period is explicitly marked as off-peak, it will be treated as off-peak in calculations. If left blank, the system will automatically treat the lowest rate as off-peak.
                        </span>
                    </div>
                    <button
                        onClick={onRemove}
                        className="sm:col-span-1 remove-btn text-xs h-8 self-center mt-2 sm:mt-0"
                    >
                        Remove
                    </button>
                </div>
            );
        };

        const WeekdayGroup = ({ group, ruleContext, onUpdateGroup, onRemoveGroup }) => {
            const handleWeekdayChange = (selectedWeekdays) => {
                onUpdateGroup({ ...group, weekdays: selectedWeekdays });
            };

            const addRatePeriod = () => {
                const newPeriod = { id: generateId(), start: "00:00", end: "00:00", amount: 0.00, isOffpeak: false };
                onUpdateGroup({ ...group, ratePeriods: [...group.ratePeriods, newPeriod] });
            };

            const updateRatePeriod = (updatedPeriod) => {
                onUpdateGroup({
                    ...group,
                    ratePeriods: group.ratePeriods.map(p => p.id === updatedPeriod.id ? updatedPeriod : p)
                });
            };

            const removeRatePeriod = (periodId) => {
                onUpdateGroup({
                    ...group,
                    ratePeriods: group.ratePeriods.filter(p => p.id !== periodId)
                });
            };

            return (
                <div className="weekday-group ml-0 md:ml-6">
                    <div className="flex justify-between items-center mb-4">
                        <h4 className="text-md font-medium text-green-700">Weekday Group (within {ruleContext})</h4>
                        <button onClick={onRemoveGroup} className="remove-btn text-xs">Remove Weekday Group</button>
                    </div>
                    <section className="mb-4">
                        <h5 className="subsection-title text-sm">Weekdays for this Group (ISO)</h5>
                        <CheckboxGroup
                            items={WEEKDAYS_DATA}
                            selectedItems={group.weekdays}
                            onChange={handleWeekdayChange}
                            allText="Select All Weekdays"
                            groupName={`weekdays-${group.id}`}
                        />
                    </section>
                    <div className="rate-periods-container space-y-3">
                        <h5 className="subsection-title text-sm">Rate Time Ranges</h5>
                        {group.ratePeriods.map(period => (
                            <RatePeriod
                                key={period.id}
                                period={period}
                                onChange={(updatedPeriod) => updateRatePeriod(updatedPeriod)}
                                onRemove={() => removeRatePeriod(period.id)}
                            />
                        ))}
                    </div>
                    <button onClick={addRatePeriod} className="add-btn text-xs add-rate-period-btn mt-3">
                        + Add Rate Period
                    </button>
                </div>
            );
        };

        const MonthRuleSet = ({ rule, type, onUpdateRule, onRemoveRule }) => {
            const titlePrefix = type === 'standard' ? 'Standard Tariff Rule' : 'Holiday Month Rule';
            const ruleContext = `${titlePrefix} #${rule.number}`;

            const handleMonthChange = (selectedMonths) => {
                onUpdateRule({ ...rule, months: selectedMonths });
            };

            const addWeekdayGroup = () => {
                const newGroup = { id: generateId(), weekdays: [], ratePeriods: [{ id: generateId(), start: "00:00", end: "00:00", amount: 0.00, isOffpeak: false }] };
                onUpdateRule({ ...rule, weekdayGroups: [...rule.weekdayGroups, newGroup] });
            };

            const updateWeekdayGroup = (updatedGroup) => {
                onUpdateRule({
                    ...rule,
                    weekdayGroups: rule.weekdayGroups.map(g => g.id === updatedGroup.id ? updatedGroup : g)
                });
            };

            const removeWeekdayGroup = (groupId) => {
                onUpdateRule({
                    ...rule,
                    weekdayGroups: rule.weekdayGroups.filter(g => g.id !== groupId)
                });
            };

            const ruleBgClass = type === 'holiday' ? 'bg-blue-50' : '';

            return (
                <div className={`tariff-rule ${ruleBgClass}`}>
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="text-lg font-medium text-blue-700">{ruleContext}</h3>
                        <button onClick={onRemoveRule} className="remove-btn">Remove Rule</button>
                    </div>
                    <section className="mb-4">
                        <h4 className="subsection-title text-md">Months for this Rule</h4>
                        <CheckboxGroup
                            items={MONTHS_DATA}
                            selectedItems={rule.months}
                            onChange={handleMonthChange}
                            allText="Select All Months"
                            groupName={`months-${rule.id}`}
                        />
                    </section>
                    <div className="weekday-groups-container space-y-4 mb-4">
                        {rule.weekdayGroups.map(group => (
                            <WeekdayGroup
                                key={group.id}
                                group={group}
                                ruleContext={ruleContext}
                                onUpdateGroup={updateWeekdayGroup}
                                onRemoveGroup={() => removeWeekdayGroup(group.id)}
                            />
                        ))}
                    </div>
                    <button onClick={addWeekdayGroup} className="add-btn text-sm add-weekday-group-btn">
                        + Add Weekday Group
                    </button>
                </div>
            );
        };

        const OverrideDateEntry = ({ entry, onChange, onRemove }) => {
            return (
                <div className="grid grid-cols-1 sm:grid-cols-3 gap-2 items-end">
                    <div>
                        <label className="input-label text-xs">Specific Date:</label>
                        <input
                            type="date"
                            value={entry.dateString} // Now storing full date string
                            onChange={(e) => onChange({ ...entry, dateString: e.target.value })}
                            className="input-field text-xs override-date"
                        />
                    </div>
                    <div className="sm:col-span-2">
                        <button onClick={onRemove} className="remove-btn text-xs h-8 w-full">Remove Date</button>
                    </div>
                </div>
            );
        };

        const OverrideRule = ({ rule, onUpdateRule, onRemoveRule }) => {
            const addDateEntry = () => {
                // Initialize with an empty string for the date picker
                const newDateEntry = { id: generateId(), dateString: '' };
                onUpdateRule({ ...rule, dates: [...rule.dates, newDateEntry] });
            };
            const updateDateEntry = (updatedEntry) => {
                onUpdateRule({ ...rule, dates: rule.dates.map(d => d.id === updatedEntry.id ? updatedEntry : d) });
            };
            const removeDateEntry = (entryId) => {
                onUpdateRule({ ...rule, dates: rule.dates.filter(d => d.id !== entryId) });
            };

            const addRatePeriod = () => {
                const newPeriod = { id: generateId(), start: "00:00", end: "00:00", amount: 0.00, isOffpeak: false };
                onUpdateRule({ ...rule, ratePeriods: [...rule.ratePeriods, newPeriod] });
            };
            const updateRatePeriod = (updatedPeriod) => {
                onUpdateRule({ ...rule, ratePeriods: rule.ratePeriods.map(p => p.id === updatedPeriod.id ? updatedPeriod : p) });
            };
            const removeRatePeriod = (periodId) => {
                onUpdateRule({ ...rule, ratePeriods: rule.ratePeriods.filter(p => p.id !== periodId) });
            };

            return (
                <div className="override-rule bg-purple-50">
                    <div className="flex justify-between items-center mb-4">
                        <h3 className="text-lg font-medium text-purple-700">Override Rule #{rule.number}</h3>
                        <button onClick={onRemoveRule} className="remove-btn">Remove Override Rule</button>
                    </div>
                    <div className="mb-4">
                        <h4 className="subsection-title text-md">Specific Dates for this Override</h4>
                        <div className="override-dates-container space-y-2 mb-3">
                            {rule.dates.map(entry => (
                                <OverrideDateEntry
                                    key={entry.id}
                                    entry={entry}
                                    onChange={updateDateEntry}
                                    onRemove={() => removeDateEntry(entry.id)}
                                />
                            ))}
                        </div>
                        <button onClick={addDateEntry} className="add-btn text-xs add-override-date-btn">
                            + Add Specific Date
                        </button>
                    </div>
                    <div>
                        <h4 className="subsection-title text-md">Rate for these Override Dates</h4>
                        <div className="override-rate-periods-container space-y-3">
                             {rule.ratePeriods.map(period => (
                                <RatePeriod
                                    key={period.id}
                                    period={period}
                                    onChange={updateRatePeriod}
                                    onRemove={() => removeRatePeriod(period.id)}
                                />
                            ))}
                        </div>
                        <button onClick={addRatePeriod} className="add-btn text-xs add-override-rate-btn mt-3">
                            + Add Rate Period
                        </button>
                    </div>
                </div>
            );
        };

        const RatePreviewChart = ({ chartData, selectedWeekStartForChart }) => {
            const chartRef = useRef(null);
            const chartInstanceRef = useRef(null);

            useEffect(() => {
                if (chartRef.current && chartData && typeof Chart !== 'undefined' && selectedWeekStartForChart) {
                    if (chartInstanceRef.current) {
                        chartInstanceRef.current.destroy();
                    }
                    const ctx = chartRef.current.getContext('2d');
                    chartInstanceRef.current = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: chartData.labels,
                            datasets: [{
                                // label: 'Value', // Legend removed
                                data: chartData.data,
                                borderColor: 'rgb(75, 192, 192)',
                                backgroundColor: 'rgba(75, 192, 192, 0.5)',
                                tension: 0.1,
                                stepped: 'before',
                                pointRadius: 0,
                                borderWidth: 2,
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                                axis: 'x'
                            },
                            scales: {
                                x: {
                                    title: { display: false },
                                    ticks: { autoSkip: true, maxTicksLimit: 24 }
                                },
                                y: {
                                    title: { display: true, text: 'Value' }, // Changed Y-axis title
                                     ticks: { callback: function(value) { return value.toFixed(2); } } // Removed currency
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    yAlign: 'top',
                                    xAlign: 'left',
                                    caretPadding: 15,
                                    callbacks: {
                                        title: function(tooltipItems) {
                                            if (!tooltipItems.length) return '';
                                            const dataIndex = tooltipItems[0].dataIndex;
                                            const dayOffset = Math.floor(dataIndex / 48);
                                            const minutesIntoDay = (dataIndex % 48) * 30;

                                            const [year, month, day] = selectedWeekStartForChart.split('-').map(Number);
                                            const baseDate = new Date(year, month - 1, day);

                                            const currentDate = new Date(baseDate);
                                            currentDate.setDate(baseDate.getDate() + dayOffset);

                                            currentDate.setHours(Math.floor(minutesIntoDay / 60));
                                            currentDate.setMinutes(minutesIntoDay % 60);

                                            const options = { weekday: 'long', year: 'numeric', month: '2-digit', day: '2-digit' };
                                            const formattedDate = currentDate.toLocaleDateString('en-GB', options);
                                            const formattedTime = `${String(currentDate.getHours()).padStart(2, '0')}:${String(currentDate.getMinutes()).padStart(2, '0')}`;
                                            return `${formattedDate} ${formattedTime}`;
                                        },
                                        label: function(tooltipItem) { return `Value: ${Number(tooltipItem.raw).toFixed(4)}`; } // Removed currency
                                    }
                                }
                            }
                        }
                    });
                }
                return () => {
                    if (chartInstanceRef.current) {
                        chartInstanceRef.current.destroy();
                        chartInstanceRef.current = null;
                    }
                };
            }, [chartData, selectedWeekStartForChart]);

            return (
                <div className="relative h-[25vh]">
                    <canvas ref={chartRef}></canvas>
                </div>
            );
        };


        // --- Main App Component ---
        const App = () => {
            const [standardRules, setStandardRules] = useState([]);
            const [holidayCountry, setHolidayCountry] = useState('');
            const [holidayState, setHolidayState] = useState('');
            const [holidayMonthRules, setHolidayMonthRules] = useState([]);
            const [fetchedHolidays, setFetchedHolidays] = useState([]);
            const [fetchedHolidaysStatus, setFetchedHolidaysStatus] = useState('Awaiting country/state input...');
            const [overrideRules, setOverrideRules] = useState([]);
            const [jsonOutput, setJsonOutput] = useState('');
            const [loadJsonInput, setLoadJsonInput] = useState('');
            const [showLoadJson, setShowLoadJson] = useState(false);
            const [statusMessage, setStatusMessage] = useState({ text: '', isError: false });

            const [selectedWeekStart, setSelectedWeekStart] = useState(() => {
                const today = new Date();
                const dayOfWeek = today.getDay();
                const diff = today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
                return new Date(today.setDate(diff)).toISOString().split('T')[0];
            });

            const clearAllConfigurations = useCallback(() => {
                setStandardRules([]);
                setHolidayCountry('');
                setHolidayState('');
                setHolidayMonthRules([]);
                setOverrideRules([]);
                setFetchedHolidays([]);
                setFetchedHolidaysStatus('Awaiting country/state input...');
                setJsonOutput('');
                setLoadJsonInput(''); // Clear input JSON as well
                setStatusMessage({ text: '', isError: false });
            }, []);

            // --- MODIFICATION START: Updated rule adding logic ---
            const addStandardRule = () => {
                const newRuleNumber = (standardRules.length > 0 ? Math.max(...standardRules.map(r => r.number)) : 0) + 1;
                const newRule = {
                    id: generateId(),
                    number: newRuleNumber,
                    months: [],
                    weekdayGroups: [{ id: generateId(), weekdays: [], ratePeriods: [{ id: generateId(), start: "00:00", end: "00:00", amount: 0.00, isOffpeak: false }] }]
                };
                setStandardRules(prev => [...prev, newRule]);
            };
            const updateStandardRule = (updatedRule) => {
                setStandardRules(prev => prev.map(r => r.id === updatedRule.id ? updatedRule : r));
            };
            const removeStandardRule = (ruleId) => {
                setStandardRules(prev => prev.filter(r => r.id !== ruleId));
            };

            const addHolidayMonthRule = () => {
                const newRuleNumber = (holidayMonthRules.length > 0 ? Math.max(...holidayMonthRules.map(r => r.number)) : 0) + 1;
                const newRule = {
                    id: generateId(),
                    number: newRuleNumber,
                    months: [],
                    weekdayGroups: [{ id: generateId(), weekdays: [], ratePeriods: [{ id: generateId(), start: "00:00", end: "00:00", amount: 0.00, isOffpeak: false }] }]
                };
                setHolidayMonthRules(prev => [...prev, newRule]);
            };
            const updateHolidayMonthRule = (updatedRule) => {
                setHolidayMonthRules(prev => prev.map(r => r.id === updatedRule.id ? updatedRule : r));
            };
            const removeHolidayMonthRule = (ruleId) => {
                setHolidayMonthRules(prev => prev.filter(r => r.id !== ruleId));
            };

            const addOverrideRuleHandler = () => {
                const newRuleNumber = (overrideRules.length > 0 ? Math.max(...overrideRules.map(r => r.number)) : 0) + 1;
                const newRule = {
                    id: generateId(),
                    number: newRuleNumber,
                    dates: [{ id: generateId(), dateString: '' }],
                    ratePeriods: [{ id: generateId(), start: "00:00", end: "00:00", amount: 0.00, isOffpeak: false }]
                };
                setOverrideRules(prev => [...prev, newRule]);
            };
            const updateOverrideRule = (updatedRule) => {
                setOverrideRules(prev => prev.map(r => r.id === updatedRule.id ? updatedRule : r));
            };
            const removeOverrideRule = (ruleId) => {
                setOverrideRules(prev => prev.filter(r => r.id !== ruleId));
            };
            // --- MODIFICATION END ---

            const fetchHolidaysCallback = useCallback(debounce(async (country, state) => {
                if (!country) {
                    setFetchedHolidays([]);
                    setFetchedHolidaysStatus('Please enter a Country Code.');
                    return;
                }
                setFetchedHolidaysStatus('Fetching holidays...');
                try {
                    if (typeof window.Holidays !== 'function') {
                        setFetchedHolidaysStatus('Holiday library not loaded.');
                        console.error("window.Holidays is not a function");
                        return;
                    }
                    const hd = new window.Holidays(country, state || undefined);
                    const holidaysData = hd.getHolidays(new Date().getFullYear());
                    if (holidaysData && holidaysData.length > 0) {
                        setFetchedHolidays(holidaysData);
                        setFetchedHolidaysStatus('');
                    } else {
                        setFetchedHolidays([]);
                        setFetchedHolidaysStatus(`No holidays found for ${country}${state ? ` (${state})` : ''} or region not supported.`);
                    }
                } catch (error) {
                    console.error("Error fetching holidays:", error);
                    let errorMsg = `Error fetching for ${country}${state ? ` (${state})` : ''}.`;
                    if (error.message && error.message.includes('country is not supported')) errorMsg = `Country '${country}' not supported.`;
                    else if (error.message && error.message.includes('state is not supported')) errorMsg = `State '${state}' not supported for '${country}'.`;
                    setFetchedHolidays([]);
                    setFetchedHolidaysStatus(errorMsg);
                }
            }, 500), []);

            useEffect(() => {
                if (holidayCountry) {
                    fetchHolidaysCallback(holidayCountry, holidayState);
                } else {
                     setFetchedHolidays([]);
                     setFetchedHolidaysStatus('Awaiting country/state input...');
                }
            }, [holidayCountry, holidayState, fetchHolidaysCallback]);
            
            const validateTimeRangesForReact = useCallback((rateTimeranges, contextMessage) => {
                if (!rateTimeranges || rateTimeranges.length === 0) {
                    return `${contextMessage}: No rate time ranges defined. Full day coverage is required.`;
                }

                if (rateTimeranges.length === 1 && rateTimeranges[0].start === rateTimeranges[0].end) {
                    const r = rateTimeranges[0];
                    if (!r.start) return `${contextMessage}: A rate period is missing a start or end time.`;
                    if (timeStringToMinutes(r.start) % 30 !== 0) return `${contextMessage}: All-day rate time ${r.start} must be on a :00 or :30 mark.`;
                    return null; 
                }

                if (rateTimeranges.some(r => r.start === r.end)) {
                    return `${contextMessage}: An all-day rate (where start time equals end time) cannot be mixed with other rate periods.`;
                }

                const minuteCoverage = new Array(MINUTES_IN_DAY).fill(0);

                for (const r of rateTimeranges) {
                    if (!r.start || !r.end) return `${contextMessage}: A rate period is missing a start or end time.`;

                    let startMinutes = timeStringToMinutes(r.start);
                    let endMinutes = (r.end === "00:00") ? MINUTES_IN_DAY : timeStringToMinutes(r.end);

                    if (startMinutes % 30 !== 0) return `${contextMessage}: Start time ${r.start} must be on a :00 or :30 mark.`;
                    if (r.end !== "00:00" && (timeStringToMinutes(r.end) % 30 !== 0)) return `${contextMessage}: End time ${r.end} must be on a :00 or :30 mark (or be "00:00" for end of day).`;

                    if (startMinutes >= endMinutes) {
                        for (let m = startMinutes; m < MINUTES_IN_DAY; m++) minuteCoverage[m]++;
                        for (let m = 0; m < endMinutes; m++) minuteCoverage[m]++;
                    } else {
                        for (let m = startMinutes; m < endMinutes; m++) minuteCoverage[m]++;
                    }
                }

                for (let m = 0; m < MINUTES_IN_DAY; m++) {
                    if (minuteCoverage[m] === 0) return `${contextMessage}: Gap in time coverage at ${formatTimeForDisplay(m)}.`;
                    if (minuteCoverage[m] > 1) return `${contextMessage}: Overlapping time periods detected around ${formatTimeForDisplay(m)}.`;
                }

                return null;
            }, []);

            const parseAndValidateRuleSetForReact = useCallback((rules, ruleTypeLabel, validationErrors, overallCoveredMonthsSet) => {
                const rulesOutput = [];
                rules.forEach(rule => {
                    const contextPrefix = `${ruleTypeLabel} #${rule.number}`;
                    if (rule.months.length === 0) { validationErrors.push(`${contextPrefix} has no months selected.`); return; }

                    rule.months.forEach(month => {
                        if (overallCoveredMonthsSet.has(month)) {
                            validationErrors.push(`Conflict: Month ${MONTHS_DATA.find(m=>m.value===month)?.name} (in ${ruleTypeLabel} #${rule.number}) is already assigned in another ${ruleTypeLabel} rule.`);
                        }
                        overallCoveredMonthsSet.add(month);
                    });

                    const weekStructureForRule = [];
                    if (rule.weekdayGroups.length === 0 && rule.months.length > 0) {
                        validationErrors.push(`${contextPrefix} (Months: ${rule.months.join(', ')}): No Weekday Groups defined.`);
                    }
                    let weekdaysCoveredInThisRule = new Set();
                    rule.weekdayGroups.forEach(group => {
                        const groupContext = `${contextPrefix}, Weekday Group (ID: ${group.id.slice(-5)})`;
                        if (group.weekdays.length === 0) { validationErrors.push(`${groupContext}: No weekdays selected.`); return; }

                        group.weekdays.forEach(wd => {
                            if (weekdaysCoveredInThisRule.has(wd)) {
                                validationErrors.push(`Conflict in ${contextPrefix}: Weekday ${WEEKDAYS_DATA.find(d=>d.value===wd)?.name} is in multiple Weekday Groups.`);
                            }
                            weekdaysCoveredInThisRule.add(wd);
                        });

                        if (group.ratePeriods.length === 0 && group.weekdays.length > 0) {
                            validationErrors.push(`${groupContext} for days [${group.weekdays.map(val => WEEKDAYS_DATA.find(d=>d.value===val)?.name).join(', ')}]: No rate time ranges defined.`);
                        }
                        const timeValidationError = validateTimeRangesForReact(group.ratePeriods, groupContext);
                        if (timeValidationError) validationErrors.push(timeValidationError);

                        if (group.ratePeriods.length > 0 && !timeValidationError) {
                            weekStructureForRule.push({
                                iso_weekday: [...group.weekdays].sort((a,b)=>a-b),
                                day_structure: {
                                    rate_timeranges: group.ratePeriods.map(rp => {
                                        const outputRp = { start: rp.start, end: rp.end, amount: rp.amount };
                                        if (rp.isOffpeak) {
                                            outputRp.label = "OFF_PEAK";
                                        }
                                        return outputRp;
                                    })
                                }
                            });
                        }
                    });
                    const missingWeekdaysInRule = ALL_WEEKDAY_NUMBERS.filter(wd => !weekdaysCoveredInThisRule.has(wd));
                    if (missingWeekdaysInRule.length > 0 && rule.months.length > 0) {
                        validationErrors.push(`${contextPrefix} (Months: ${rule.months.map(val=>MONTHS_DATA.find(m=>m.value===val)?.name).join(', ')}): Weekdays [${missingWeekdaysInRule.map(val => WEEKDAYS_DATA.find(d=>d.value===val)?.name).join(', ')}] are not covered.`);
                    }
                    if (weekStructureForRule.length > 0) {
                        rulesOutput.push({ month: [...rule.months].sort((a,b)=>a-b), week_structure: weekStructureForRule });
                    }
                });
                return rulesOutput;
            }, [validateTimeRangesForReact]);


            const handleGenerateJson = useCallback(() => {
                let validationErrors = [];
                const finalJson = {};

                let overallStandardMonthsCovered = new Set();
                const parsedStandardRules = parseAndValidateRuleSetForReact(standardRules, 'Standard Tariff Rule', validationErrors, overallStandardMonthsCovered);
                if (parsedStandardRules.length > 0) finalJson.month_structure = parsedStandardRules;
                const missingStandardMonths = ALL_MONTH_NUMBERS.filter(m => !overallStandardMonthsCovered.has(m));
                if (missingStandardMonths.length > 0) validationErrors.push(`Overall Standard Tariff: Months [${missingStandardMonths.map(val=>MONTHS_DATA.find(m=>m.value===val)?.name).join(', ')}] are not covered.`);
                if (standardRules.length === 0) validationErrors.push("No Standard Tariff Rules defined. At least one standard rule covering all months is required.");

                if (holidayMonthRules.length > 0 || holidayCountry || holidayState) {
                    if (!holidayCountry) validationErrors.push("Country Holidays: Country code is missing if holiday rules are defined or state is entered.");
                    let overallHolidayMonthsCovered = new Set();
                    const parsedHolidayRules = parseAndValidateRuleSetForReact(holidayMonthRules, 'Holiday Month Rule', validationErrors, overallHolidayMonthsCovered);
                    if (parsedHolidayRules.length > 0) {
                        finalJson.country_holidays = { country: holidayCountry };
                        if (holidayState) finalJson.country_holidays.state = holidayState;
                        finalJson.country_holidays.month_structure = parsedHolidayRules;
                        const missingHolidayMonths = ALL_MONTH_NUMBERS.filter(m => !overallHolidayMonthsCovered.has(m));
                        if (missingHolidayMonths.length > 0) validationErrors.push(`Country Holidays Definition: Months [${missingHolidayMonths.map(val=>MONTHS_DATA.find(m=>m.value===val)?.name).join(', ')}] are not covered within the holiday rules.`);
                    } else if (holidayMonthRules.length > 0 && holidayCountry) {
                        // Errors already pushed
                    }
                }

                const parsedOverrideRules = [];
                let allOverriddenDates = new Set(); // Use this to check for duplicate override dates
                overrideRules.forEach(rule => {
                    const overrideContext = `Override Rule #${rule.number}`;
                    const annualDatesMap = new Map();

                    if (rule.dates.length === 0) {
                        validationErrors.push(`${overrideContext}: No specific dates defined for override.`);
                    }

                    rule.dates.forEach(entry => {
                        if (!entry.dateString) {
                            validationErrors.push(`${overrideContext}: An override date entry is empty.`);
                            return;
                        }

                        const [year, month, day] = entry.dateString.split('-').map(Number);
                        const dateKey = `${month}-${day}`;

                        if (allOverriddenDates.has(dateKey)) {
                            validationErrors.push(`Conflict: Date ${MONTHS_DATA.find(m=>m.value===month)?.name} ${day} is defined in multiple Override Rules or multiple times within the same rule.`);
                        }
                        allOverriddenDates.add(dateKey);

                        if (!annualDatesMap.has(month)) {
                            annualDatesMap.set(month, []);
                        }
                        annualDatesMap.get(month).push(day);
                    });

                    const annualDates = Array.from(annualDatesMap.entries()).map(([month, days]) => ({
                        month: month,
                        days: days.sort((a, b) => a - b)
                    }));
                    
                    if (rule.ratePeriods.length === 0 && annualDates.length > 0) validationErrors.push(`${overrideContext}: No rate time ranges defined for the specified dates.`);
                    const timeValidationError = validateTimeRangesForReact(rule.ratePeriods, overrideContext);
                    if (timeValidationError) validationErrors.push(timeValidationError);

                    if (annualDates.length > 0 && rule.ratePeriods.length > 0 && !timeValidationError) {
                        parsedOverrideRules.push({
                            annual_date: annualDates,
                            day_structure: {
                                rate_timeranges: rule.ratePeriods.map(rp => {
                                    const outputRp = { start: rp.start, end: rp.end, amount: rp.amount };
                                    if (rp.isOffpeak) {
                                        outputRp.label = "OFF_PEAK";
                                    }
                                    return outputRp;
                                })
                            }
                        });
                    }
                });
                if (parsedOverrideRules.length > 0) finalJson.override = parsedOverrideRules;

                if (validationErrors.length > 0) {
                    setStatusMessage({ text: `Validation Errors Found (Fix and Regenerate):\n- ${validationErrors.join('\n- ')}`, isError: true });
                    setJsonOutput('');
                } else {
                    if (Object.keys(finalJson).length === 0 || !finalJson.month_structure) {
                        setStatusMessage({ text: "No valid tariff data to generate. Ensure at least standard tariff rules are fully configured and valid.", isError: true });
                        setJsonOutput('');
                    } else {
                        setJsonOutput(JSON.stringify(finalJson, null, 2));
                        setStatusMessage({ text: "JSON generated successfully after passing all validations!", isError: false });
                    }
                }
            }, [standardRules, holidayMonthRules, overrideRules, holidayCountry, holidayState, parseAndValidateRuleSetForReact, validateTimeRangesForReact]);

            const handleLoadJson = useCallback((jsonToLoad) => {
                try {
                    const jsonString = typeof jsonToLoad === 'string' ? jsonToLoad : loadJsonInput;
                     if (!jsonString) {
                        setStatusMessage({ text: "No JSON data to load.", isError: true });
                        return;
                    }
                    const parsedJson = JSON.parse(jsonString);
                    clearAllConfigurations();

                    // Reconstruct standard rules
                    if (parsedJson.month_structure) {
                        const newStandardRules = parsedJson.month_structure.map((rule, idx) => {
                            const newWeekdayGroups = rule.week_structure.map(wg => ({
                                id: generateId(),
                                weekdays: wg.iso_weekday,
                                ratePeriods: wg.day_structure.rate_timeranges.map(rp => ({
                                    id: generateId(),
                                    start: formatTimeForDisplay(timeStringToMinutes(rp.start)),
                                    end: formatTimeForDisplay(timeStringToMinutes(rp.end)),
                                    amount: rp.amount,
                                    isOffpeak: rp.label === "OFF_PEAK"
                                }))
                            }));
                            return {
                                id: generateId(),
                                number: idx + 1,
                                months: rule.month,
                                weekdayGroups: newWeekdayGroups
                            };
                        });
                        setStandardRules(newStandardRules);
                    }

                    // Reconstruct country holidays
                    if (parsedJson.country_holidays) {
                        setHolidayCountry(parsedJson.country_holidays.country || '');
                        setHolidayState(parsedJson.country_holidays.state || '');
                        if (parsedJson.country_holidays.month_structure) {
                            const newHolidayRules = parsedJson.country_holidays.month_structure.map((rule, idx) => {
                                const newWeekdayGroups = rule.week_structure.map(wg => ({
                                    id: generateId(),
                                    weekdays: wg.iso_weekday,
                                    ratePeriods: wg.day_structure.rate_timeranges.map(rp => ({
                                        id: generateId(),
                                        start: formatTimeForDisplay(timeStringToMinutes(rp.start)),
                                        end: formatTimeForDisplay(timeStringToMinutes(rp.end)),
                                        amount: rp.amount,
                                        isOffpeak: rp.label === "OFF_PEAK"
                                    }))
                                }));
                                return {
                                    id: generateId(),
                                    number: idx + 1,
                                    months: rule.month,
                                    weekdayGroups: newWeekdayGroups
                                };
                            });
                            setHolidayMonthRules(newHolidayRules);
                        }
                    }

                    // Reconstruct override rules
                    if (parsedJson.override) {
                        const newOverrideRules = parsedJson.override.map((rule, idx) => {
                            const newDates = [];
                            rule.annual_date.forEach(ad => {
                                const yearForDisplay = 2024;
                                ad.days.forEach(day => {
                                    const monthStr = String(ad.month).padStart(2, '0');
                                    const dayStr = String(day).padStart(2, '0');
                                    newDates.push({
                                        id: generateId(),
                                        dateString: `${yearForDisplay}-${monthStr}-${dayStr}`
                                    });
                                });
                            });

                            const newRatePeriods = rule.day_structure.rate_timeranges.map(rp => ({
                                id: generateId(),
                                start: formatTimeForDisplay(timeStringToMinutes(rp.start)),
                                end: formatTimeForDisplay(timeStringToMinutes(rp.end)),
                                amount: rp.amount,
                                isOffpeak: rp.label === "OFF_PEAK"
                            }));
                            return {
                                id: generateId(),
                                number: idx + 1,
                                dates: newDates,
                                ratePeriods: newRatePeriods
                            };
                        });
                        setOverrideRules(newOverrideRules);
                    }

                    setStatusMessage({ text: "JSON loaded successfully! Generating output...", isError: false });
                } catch (error) {
                    console.error("Error loading JSON:", error);
                    setStatusMessage({ text: `Failed to load JSON: ${error.message}. Please check format.`, isError: true });
                }
            }, [loadJsonInput, clearAllConfigurations]);


            // --- Example Loaders ---
            const loadFlatRateExample = useCallback(() => {
                clearAllConfigurations();
                setStandardRules([{
                    id: 'std-flat-1', number: 1, months: [...ALL_MONTH_NUMBERS],
                    weekdayGroups: [{ id: 'std-flat-wg-1', weekdays: [...ALL_WEEKDAY_NUMBERS], ratePeriods: [{id: 'std-flat-rp-1', start: "00:00", end: "00:00", amount: 0.15, isOffpeak: false }] }]
                }]);
                setStatusMessage({ text: "Flat Rate example loaded.", isError: false });
            }, [clearAllConfigurations]);

            const loadDualRateExample = useCallback(() => {
                clearAllConfigurations();
                setStandardRules([{
                    id: 'std-dual-1', number: 1, months: [...ALL_MONTH_NUMBERS],
                    weekdayGroups: [{
                        id: 'std-dual-wg-1', weekdays: [...ALL_WEEKDAY_NUMBERS],
                        ratePeriods: [
                            { id: 'std-dual-rp-1', start: "00:00", end: "07:00", amount: 0.10, isOffpeak: true },
                            { id: 'std-dual-rp-2', start: "07:00", end: "00:00", amount: 0.25, isOffpeak: false }
                        ]
                    }]
                }]);
                setStatusMessage({ text: "Dual Rate example loaded.", isError: false });
            }, [clearAllConfigurations]);

            const loadDualRateWeekendsOffpeakExample = useCallback(() => {
                clearAllConfigurations();
                setStandardRules([{
                    id: 'std-dualwknd-1', number: 1, months: [...ALL_MONTH_NUMBERS],
                    weekdayGroups: [
                        {
                            id: 'std-dualwknd-wg-1', weekdays: [1,2,3,4,5],
                            ratePeriods: [
                                { id: 'std-dualwknd-rp-1', start: "00:00", end: "07:00", amount: 0.10, isOffpeak: true },
                                { id: 'std-dualwknd-rp-2', start: "07:00", end: "00:00", amount: 0.25, isOffpeak: false }
                            ]
                        },
                        {
                            id: 'std-dualwknd-wg-2', weekdays: [6,7],
                            ratePeriods: [{ id: 'std-dualwknd-rp-3', start: "00:00", end: "00:00", amount: 0.10, isOffpeak: true }]
                        }
                    ]
                }]);
                setStatusMessage({ text: "Dual Rate (Weekends Off-peak) example loaded.", isError: false });
            }, [clearAllConfigurations]);

            const loadFullyComplicatedExample = useCallback(() => {
                clearAllConfigurations();
                setStandardRules([
                    {
                        id: 'std-comp-1', number: 1, months: [1, 2, 3, 10, 11, 12],
                        weekdayGroups: [
                            { id: 'std-comp-wg-1', weekdays: [1,2,3,4,5], ratePeriods: [{ id: 'std-comp-rp-1', start: "00:00", end: "12:00", amount: 0.10, isOffpeak: true }, { id: 'std-comp-rp-2', start: "12:00", end: "00:00", amount: 0.20, isOffpeak: false }] },
                            { id: 'std-comp-wg-2', weekdays: [6,7], ratePeriods: [{ id: 'std-comp-rp-3', start: "00:00", end: "00:00", amount: 0.10, isOffpeak: true }] }
                        ]
                    },
                    {
                        id: 'std-comp-2', number: 2, months: [4,5,6,7,8,9],
                        weekdayGroups: [{ id: 'std-comp-wg-3', weekdays: [...ALL_WEEKDAY_NUMBERS], ratePeriods: [{ id: 'std-comp-rp-4', start: "00:00", end: "00:00", amount: 0.10, isOffpeak: true }]}]
                    }
                ]);
                setHolidayCountry("AU");
                setHolidayState("ACT");
                setHolidayMonthRules([
                    { id: 'hol-comp-1', number: 1, months: [1], weekdayGroups: [{id: 'hol-comp-wg-1', weekdays: [...ALL_WEEKDAY_NUMBERS], ratePeriods: [{id: 'hol-comp-rp-1', start:"00:00", end:"00:00", amount: 0.01, isOffpeak: true}] }]},
                    { id: 'hol-comp-2', number: 2, months: [2,3,4,5,6,7,8,9,10,11,12], weekdayGroups: [{id: 'hol-comp-wg-2', weekdays: [...ALL_WEEKDAY_NUMBERS], ratePeriods: [{id: 'hol-comp-rp-2', start:"00:00", end:"00:00", amount: 0.02, isOffpeak: true}] }]}
                ]);
                setOverrideRules([{
                    id: 'ovr-comp-1', number: 1,
                    dates: [ {id: 'ovr-dt-1', dateString: '2025-12-25'}, {id: 'ovr-dt-2', dateString: '2025-12-31'}, {id: 'ovr-dt-3', dateString: '2024-02-29'} ],
                    ratePeriods: [{id: 'ovr-rp-1', start: "00:00", end: "00:00", amount: 0.10, isOffpeak: false}]
                }]);
                setStatusMessage({ text: "Fully Complicated example loaded.", isError: false });
            }, [clearAllConfigurations]);

            useEffect(() => {
                handleGenerateJson();
            }, [standardRules, holidayMonthRules, overrideRules, holidayCountry, holidayState, handleGenerateJson]);

            // --- New: Handle loading from URL on initial mount ---
            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const schemaParam = urlParams.get('schema');

                if (schemaParam && window.pako) {
                    try {
                        // Decode from URL-safe Base64
                        const base64String = schemaParam.replace(/-/g, '+').replace(/_/g, '/');
                        const compressedString = atob(base64String);
                        const compressedArray = new Uint8Array([...compressedString].map(char => char.charCodeAt(0)));
                        
                        // Decompress using pako
                        const decompressedJson = pako.inflate(compressedArray, { to: 'string' });

                        // Load the schema from the decompressed JSON
                        handleLoadJson(decompressedJson);
                        setStatusMessage({ text: "Tariff schema successfully loaded from URL.", isError: false });
                        
                        // Scroll to the chart section after a brief delay to allow for rendering
                        setTimeout(() => {
                            const chartElement = document.getElementById('sticky-chart-section');
                            if (chartElement) {
                                chartElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        }, 100);

                    } catch (e) {
                        console.error("Failed to parse schema from URL:", e);
                        setStatusMessage({ text: `Error: Could not load schema from URL. ${e.message}`, isError: true });
                        loadFlatRateExample(); // Fallback to default
                    }
                } else {
                    // No schema in URL, load a default example
                    loadFlatRateExample();
                }
            }, []); // Empty dependency array ensures this runs only once on mount

            // --- New: Handle sharing ---
            const handleShare = useCallback(() => {
                if (!jsonOutput) {
                    setStatusMessage({ text: "Please generate a valid JSON first before sharing.", isError: true });
                    return;
                }
                if (!window.pako) {
                    setStatusMessage({ text: "Compression library (pako) not loaded. Cannot create share link.", isError: true });
                    return;
                }

                try {
                    // Compress the JSON output using pako
                    const compressed = pako.deflate(jsonOutput, { to: 'string' });
                    
                    // Encode to URL-safe Base64
                    const base64 = btoa(String.fromCharCode.apply(null, compressed));
                    const urlSafeBase64 = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');

                    // Create the full URL
                    const newUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}?schema=${urlSafeBase64}`;

                    // Copy to clipboard
                    navigator.clipboard.writeText(newUrl).then(() => {
                        setStatusMessage({ text: "Sharable URL copied to clipboard!", isError: false });
                        // Also update the browser's address bar
                        window.history.pushState({ path: newUrl }, '', newUrl);
                    }).catch(err => {
                        console.error("Failed to copy URL: ", err);
                        setStatusMessage({ text: "Failed to copy URL. It has been set in your address bar for manual copying.", isError: true });
                        window.history.pushState({ path: newUrl }, '', newUrl);
                    });

                } catch (error) {
                    console.error("Failed to create share link:", error);
                    setStatusMessage({ text: `Error creating share link: ${error.message}`, isError: true });
                }
            }, [jsonOutput]);


            // --- Chart Data Generation ---
            const chartData = useMemo(() => {
                const getRateForMinute = (ratePeriods, minutesIntoDay) => {
                    for (const rp of ratePeriods) {
                        if (rp.start === rp.end) {
                            return rp.amount;
                        }

                        const startM = timeStringToMinutes(rp.start);
                        const endM = (rp.end === "00:00") ? MINUTES_IN_DAY : timeStringToMinutes(rp.end);

                        if (startM < endM) { // Normal day period
                            if (minutesIntoDay >= startM && minutesIntoDay < endM) {
                                return rp.amount;
                            }
                        } else { // Overnight period
                            if (minutesIntoDay >= startM || minutesIntoDay < endM) {
                                return rp.amount;
                            }
                        }
                    }
                    return null;
                };

                const weekStart = new Date(selectedWeekStart + "T00:00:00");
                const labels = [];
                const dataPoints = [];
                let currentHolidays = [];

                if (holidayCountry && window.Holidays) {
                    try {
                        const hd = new window.Holidays(holidayCountry, holidayState || undefined);
                        currentHolidays = hd.getHolidays(weekStart.getFullYear());
                        if (new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate() + 6).getFullYear() > weekStart.getFullYear()) {
                            currentHolidays = currentHolidays.concat(hd.getHolidays(weekStart.getFullYear() + 1));
                        }
                    } catch (e) { console.warn("Could not fetch holidays for chart:", e); }
                }

                for (let dayOffset = 0; dayOffset < 7; dayOffset++) {
                    const currentDate = new Date(weekStart);
                    currentDate.setDate(weekStart.getDate() + dayOffset);
                    const currentMonth = currentDate.getMonth() + 1;
                    const currentDayOfMonth = currentDate.getDate();
                    const currentYear = currentDate.getFullYear();
                    let currentIsoWeekday = currentDate.getDay();
                    if (currentIsoWeekday === 0) currentIsoWeekday = 7;

                    const dateStringForHolidayCheck = `${currentYear}-${String(currentMonth).padStart(2,'0')}-${String(currentDayOfMonth).padStart(2,'0')}`;
                    const isHoliday = currentHolidays.some(h => h.date.startsWith(dateStringForHolidayCheck));

                    for (let interval = 0; interval < 48; interval++) {
                        const minutesIntoDay = interval * 30;
                        const timeLabel = formatTimeForDisplay(minutesIntoDay);
                        const dayLabel = WEEKDAYS_DATA.find(wd => wd.value === currentIsoWeekday)?.name.substring(0,3) || 'Day';
                        labels.push(`${dayLabel} ${timeLabel}`);

                        let rate = null;

                        const activeOverride = overrideRules.find(or =>
                            or.dates.some(d => {
                                if (d.dateString) {
                                    const [, m, day] = d.dateString.split('-').map(Number);
                                    return m === currentMonth && day === currentDayOfMonth;
                                }
                                return false;
                            })
                        );
                        if (activeOverride) {
                            rate = getRateForMinute(activeOverride.ratePeriods, minutesIntoDay);
                        }

                        if (rate === null && isHoliday && holidayCountry) {
                             const applicableHolidayRule = holidayMonthRules.find(hr => hr.months.includes(currentMonth));
                             if(applicableHolidayRule) {
                                const applicableWeekdayGroup = applicableHolidayRule.weekdayGroups.find(wg => wg.weekdays.includes(currentIsoWeekday));
                                if(applicableWeekdayGroup) {
                                    rate = getRateForMinute(applicableWeekdayGroup.ratePeriods, minutesIntoDay);
                                }
                             }
                        }

                        if (rate === null) {
                            const applicableStandardRule = standardRules.find(sr => sr.months.includes(currentMonth));
                            if(applicableStandardRule) {
                                const applicableWeekdayGroup = applicableStandardRule.weekdayGroups.find(wg => wg.weekdays.includes(currentIsoWeekday));
                                if(applicableWeekdayGroup) {
                                     rate = getRateForMinute(applicableWeekdayGroup.ratePeriods, minutesIntoDay);
                                }
                            }
                        }
                        dataPoints.push(rate !== null ? rate : 0);
                    }
                }
                return { labels, data: dataPoints };
            }, [selectedWeekStart, standardRules, holidayMonthRules, overrideRules, holidayCountry, holidayState, fetchedHolidays]);


            return (
                <div className="max-w-6xl mx-auto bg-white p-6 md:p-8 rounded-xl shadow-2xl">
                    <header className="mb-10 text-center">
                        <h1 className="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-indigo-600">Schema Designer</h1>
                        <p className="text-gray-600 mt-3 text-lg">Define standard rates, country-specific holidays, and date overrides with full validation.</p>
                    </header>

                    <section id="load-json-section" className="section-container mb-10 bg-purple-50 border-purple-200">
                        <div className="collapsible-header" onClick={() => setShowLoadJson(!showLoadJson)}>
                            Load an Existing Tariff JSON
                            <svg className={`w-6 h-6 collapsible-arrow ${showLoadJson ? 'rotated' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7"></path></svg>
                        </div>
                        {showLoadJson && (
                            <div className="json-load-content">
                                <p className="text-sm text-gray-600 mb-4">Paste your tariff schema JSON below to load it into the designer. This will clear the current configuration.</p>
                                <textarea
                                    id="jsonInputReact"
                                    rows="10"
                                    className="w-full p-4 border border-gray-300 rounded-md bg-gray-100 text-sm font-mono focus:ring-2 focus:ring-purple-500 focus:border-purple-500"
                                    value={loadJsonInput}
                                    onChange={(e) => setLoadJsonInput(e.target.value)}
                                    placeholder='Paste your JSON here, e.g., { "month_structure": [...], "override": [...] }'
                                ></textarea>
                                <button onClick={() => handleLoadJson()} className="mt-4 w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out text-lg">
                                    Load JSON
                                </button>
                            </div>
                        )}
                    </section>


                    <section className="section-container mb-10 bg-indigo-50 border-indigo-200">
                        <h2 className="section-header text-indigo-700 border-indigo-400">Quick Start Examples</h2>
                        <p className="text-sm text-gray-600 mb-6">Select an example to pre-fill the designer. This will clear any current configuration.</p>
                        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
                            <button onClick={loadFlatRateExample} className="quick-start-btn">Flat Rate</button>
                            <button onClick={loadDualRateExample} className="quick-start-btn">Dual Rate</button>
                            <button onClick={loadDualRateWeekendsOffpeakExample} className="quick-start-btn">Dual Rate (Weekend Off-peak)</button>
                            <button onClick={loadFullyComplicatedExample} className="quick-start-btn">Fully Complicated Example</button>
                        </div>
                    </section>

                    <section id="sticky-chart-section" className="section-container sticky-chart-section !py-2 px-6">
                        <div className="flex items-center mb-1">
                            <label htmlFor="weekPicker" className="input-label mr-2 mb-0">Select Week to Preview:</label>
                            <input
                                type="date"
                                id="weekPicker"
                                value={selectedWeekStart}
                                onChange={(e) => setSelectedWeekStart(e.target.value)}
                                className="input-field w-auto md:w-1/3"
                            />
                             {statusMessage.isError && statusMessage.text && (
                                <span className="chart-warning-icon">
                                    
                                    <span className="tooltip-text" dangerouslySetInnerHTML={{ __html: statusMessage.text.replace(/\n- /g, '<br/>- ') }} />
                                </span>
                            )}
                        </div>
                        <RatePreviewChart chartData={chartData} selectedWeekStartForChart={selectedWeekStart} />
                    </section>


                    <section className="section-container">
                        <h2 className="section-header">Standard Tariff Rules</h2>
                        <div id="tariffRulesContainerReact" className="space-y-6 mb-6">
                            {standardRules.map(rule => (
                                <MonthRuleSet
                                    key={rule.id}
                                    rule={rule}
                                    type="standard"
                                    onUpdateRule={updateStandardRule}
                                    onRemoveRule={() => removeStandardRule(rule.id)}
                                />
                            ))}
                        </div>
                        <button onClick={addStandardRule} className="add-btn w-full sm:w-auto">+ Add Standard Tariff Rule</button>
                    </section>

                    <section className="section-container">
                        <h2 className="section-header">Country Holidays</h2>
                        <div id="countryHolidaysConfigReact" className="mb-6 p-4 border border-dashed border-blue-300 rounded-lg bg-blue-50">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                <div>
                                    <label htmlFor="holidayCountryReact" className="input-label">Country Code (e.g., AU):</label>
                                    <input type="text" id="holidayCountryReact" className="input-field" placeholder="AU" value={holidayCountry} onChange={e => setHolidayCountry(e.target.value.toUpperCase())} />
                                </div>
                                <div>
                                    <label htmlFor="holidayStateReact" className="input-label">State/Region Code (Optional, e.g., ACT):</label>
                                    <input type="text" id="holidayStateReact" className="input-field" placeholder="ACT" value={holidayState} onChange={e => setHolidayState(e.target.value.toUpperCase())} />
                                </div>
                            </div>
                            <div id="fetchedHolidaysListContainerReact" className="mt-4">
                                <p className="text-sm text-gray-600 mb-1">Recognized public holidays for {new Date(selectedWeekStart).getFullYear()}:</p>
                                <div id="fetchedHolidaysListReact" className="text-xs max-h-32 overflow-y-auto bg-indigo-100 p-2 rounded">
                                    {fetchedHolidaysStatus && <p className="text-gray-500">{fetchedHolidaysStatus}</p>}
                                    {fetchedHolidays.length > 0 && (
                                        <ul className="list-disc list-inside space-y-0.5">
                                            {fetchedHolidays.map(h => (
                                                <li key={h.date}><strong>{new Date(h.date).toLocaleDateString(undefined, {month:'short', day:'numeric'})}:</strong> {h.name}</li>
                                            ))}
                                        </ul>
                                    )}
                                </div>
                            </div>
                            <p className="text-sm text-gray-600 mb-1 mt-4">Define specific rate structures for holidays within the selected country/state.</p>
                        </div>
                        <div id="holidayMonthRulesContainerReact" className="space-y-6 mb-6">
                             {holidayMonthRules.map(rule => (
                                <MonthRuleSet
                                    key={rule.id}
                                    rule={rule}
                                    type="holiday"
                                    onUpdateRule={updateHolidayMonthRule}
                                    onRemoveRule={() => removeHolidayMonthRule(rule.id)}
                                />
                            ))}
                        </div>
                        <button onClick={addHolidayMonthRule} className="add-btn w-full sm:w-auto bg-blue-500 hover:bg-blue-600">+ Add Holiday Month Rule</button>
                    </section>

                    <section className="section-container">
                        <h2 className="section-header">Override Specific Days</h2>
                        <p className="text-sm text-gray-600 mb-4">Define special rates for specific calendar dates (e.g., Christmas, New Year's Eve).</p>
                        <div id="overrideRulesContainerReact" className="space-y-6 mb-6">
                            {overrideRules.map(rule => (
                                <OverrideRule
                                    key={rule.id}
                                    rule={rule}
                                    onUpdateRule={updateOverrideRule}
                                    onRemoveRule={() => removeOverrideRule(rule.id)}
                                />
                            ))}
                        </div>
                        <button onClick={addOverrideRuleHandler} className="add-btn w-full sm:w-auto bg-purple-500 hover:bg-purple-600">+ Add Override Day Rule</button>
                    </section>

                    <section className="mt-10 p-6 bg-gray-50 rounded-lg shadow-inner">
                        <h2 className="subsection-title text-xl mb-4 text-gray-700 border-b pb-2">Generate, Share & View JSON</h2>
                        <div className="flex flex-col sm:flex-row gap-4 mb-4">
                            <button onClick={handleGenerateJson} className="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out text-lg">Validate & Generate JSON</button>
                            <button onClick={handleShare} className="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out text-lg" disabled={!jsonOutput}>Share Schema</button>
                            <button
                                onClick={() => {
                                    if (typeof window.copyJsonToClipboardGlobal === 'function') {
                                        window.copyJsonToClipboardGlobal(jsonOutput, setStatusMessage);
                                    }
                                }}
                                className="flex-1 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out text-lg"
                                disabled={!jsonOutput}
                            >
                                Copy JSON to Clipboard
                            </button>
                        </div>
                        {statusMessage.text && (
                             <div
                                id="statusMessageReact"
                                className={`mb-2 text-sm font-medium text-center p-2 rounded-md ${statusMessage.isError ? 'text-red-700 bg-red-100 border border-red-300 text-left' : 'text-green-700 bg-green-100 border border-green-300'}`}
                                dangerouslySetInnerHTML={{ __html: statusMessage.text.replace(/\n/g, '<br>') }}
                             />
                        )}
                        <textarea id="jsonOutputReact" rows="20" className="w-full p-4 border border-gray-300 rounded-md bg-gray-100 text-sm font-mono focus:ring-2 focus:ring-blue-500 focus:border-blue-500" value={jsonOutput} readOnly placeholder="JSON output will appear here after successful validation..."></textarea>
                    </section>

                    <footer className="text-center text-sm text-gray-500 mt-12">
                        <p>&copy; <span id="currentYearReact">{new Date().getFullYear()}</span> Schema Designer Interface. Internal Use Only.</p>
                    </footer>
                </div>
            );
        };

        window.showStatusMessageGlobal = (message, isError, reactSetStatusMessage) => {
            if (reactSetStatusMessage) {
                reactSetStatusMessage({text: message, isError: isError });
            }
        };

        window.copyJsonToClipboardGlobal = (textToCopy, reactSetStatusMessage) => {
            const showStatus = (msg, isErr) => window.showStatusMessageGlobal(msg, isErr, reactSetStatusMessage);
            if (!textToCopy) {
                showStatus("Nothing to copy. Generate JSON first.", true);
                return;
            }
            navigator.clipboard.writeText(textToCopy)
                .then(() => {
                     showStatus("JSON copied to clipboard!", false);
                })
                .catch(err => {
                    console.error('Clipboard copy error:', err);
                    showStatus(`<b>Clipboard Error:</b> ${err.message}`, true);
                });
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>

</body>
</html>
